{
  "thema": "Vernünftige Umsetzung von WebAuthn",
  "kontext": {
    "ziel": "WebAuthn so zu implementieren, dass es nicht nur technisch korrekt ist, sondern auch UX-freundlich, konfigurierbar und für Entwickler sinnvoll erweiterbar. Gleichzeitig sollen gängige faule Ausreden (wie z. B. 'braucht eh keiner', 'zu kompliziert', 'machen wir später') entkräftet werden.",
    "perspektive": "Technisch versierter Nutzer mit Fokus auf Selbsthosting, Datenschutz, Nutzerkontrolle und Modularität."
  },
  "grundprinzipien": {
    "modularitaet": "WebAuthn sollte in Module aufgeteilt sein – z. B. für Registrierung, Login, Fallback-Optionen, Anzeige im Backend. Kein monolithisches Verhalten.",
    "kompatibilitaet": "Unterstützung für alle gängigen Browser, keine künstlichen Einschränkungen (wie 'nur Chromium' oder 'nur mit JavaScript-Framework X').",
    "fallbacks": "Fallbacks wie TOTP, Scratch-Codes oder Notfallcodes müssen vorhanden und verwaltbar sein. Andernfalls entsteht faktisch eine Account-Sperre bei Geräteverlust.",
    "u2f_migration": "Alte U2F-Schlüssel sollten erkennbar migrierbar sein, wenn technisch möglich.",
    "policy_support": "Admins (z. B. im Selfhosted-Umfeld) müssen Policies setzen können – z. B. 'mind. 1 FIDO-Key + 1 Backup-Methode notwendig'.",
    "mehrfach_devices": "Mehrere WebAuthn-Keys müssen ohne Einschränkungen unterstützt werden. Benutzer sollten ihre Geräte benennen können.",
    "anzeige": "Im Backend muss eine Übersicht über registrierte Devices möglich sein (inkl. Name, Typ, zuletzt genutzt, Löschoption).",
    "export_import": "Optional: Möglichkeit zur Export-Import-Funktion der Key-Referenzen im Selfhosted-Bereich, z. B. für Migrationen.",
    "browser_klarheit": "Auf der Client-Seite muss klar angezeigt werden, was gerade erwartet wird (Registrierung vs. Login, Key-Auswahl, Touch, etc.).",
    "i18n": "Alle Anzeigen und Fehlermeldungen müssen übersetzbar sein, keine hardcodierten englischen Texte.",
    "framework_unabhaengigkeit": "Keine erzwungene Abhängigkeit von React, Vue o. Ä. WebAuthn muss auch vanilla umsetzbar sein.",
    "privacy_respekt": "Keine unnötige Übermittlung von Daten – Username-first Flows vermeiden Metadatenleaks."
  },
  "entwickler_fokus": {
    "doku": "Klare Entwicklerdokumentation, wie man eigene Policies, Views und Hooks einbindet.",
    "api_hooks": "WebAuthn-Logik muss Hooks oder Events bereitstellen, z. B. nach erfolgreicher Auth, zur Log-Erweiterung, für Plugins.",
    "admin_ui": "Admins sollten den Status von Keys einsehen und ggf. deaktivieren können – z. B. nach Diebstahl oder Keyverlust.",
    "testbarkeit": "WebAuthn muss in Testumgebungen automatisiert testbar sein – z. B. über Emulatoren oder manuelle Key-Mocks."
  },
  "anti_faulheits_argumentation": {
    "web_authn_nutzerargumente": [
      "Viele User *wollen* FIDO – vor allem Tech-Affine, Admins, Poweruser.",
      "Wenn Fallbacks fehlen, wird’s unsicher (User speichern Keys als Screenshot).",
      "Ohne vernünftige UI versteht kein Normalnutzer, was WebAuthn gerade will."
    ],
    "entwickler_argumente": [
      "Ein richtig implementiertes WebAuthn-Modul ist einmal Aufwand – aber dann ewig wiederverwendbar.",
      "Standards wie WebAuthn sind *nicht* optional, wenn man MFA ernst nimmt.",
      "Wenn FIDO-Optionen fehlen, weichen Nutzer auf unsicherere Alternativen aus (SMS, Mail)."
    ],
    "wartbarkeit": [
      "Modulare Implementierung = Updateschritte einfacher.",
      "Saubere Trennung erlaubt Weiterentwicklung einzelner Teile ohne Gesamtsystem zu gefährden.",
      "Mit Konfigurationslayer ist Anpassung an jede Zielgruppe (intern, extern, Enterprise, Schule, Forum) möglich."
    ],
    "ausrede_entkraeftung": {
      "ausrede_1": "Ist zu kompliziert",
      "antwort_1": "Es gibt Libraries, Beispielcode und Dev-Tools – wer WebAuthn 'zu kompliziert' nennt, hat sich nicht damit befasst.",
      "ausrede_2": "Brauchen unsere Nutzer eh nicht",
      "antwort_2": "Jeder Nutzer, der ein Passwort verliert oder seine 2FA neu aufsetzen muss, *hätte* davon profitiert. Das merkt man nur oft zu spät.",
      "ausrede_3": "Ist zu neu / instabil",
      "antwort_3": "WebAuthn ist seit Jahren ein stabiler W3C-Standard mit breiter Browserunterstützung. Die meisten Key-Probleme sind durch schlechte UX bedingt, nicht durch Technik."
    }
  },
  "vision": {
    "zielbild": "WebAuthn wird als natürliche MFA-Erweiterung gesehen, die sich flexibel anpassen lässt, ohne Nutzer zu überfordern oder Admins zu blockieren.",
    "user_story": [
      "Ein Nutzer kann mehrere Keys registrieren, einen verlorenen Key selbst deaktivieren und hat Notfallcodes als Backup.",
      "Ein Admin kann im Backend sehen, welche Keys aktiv sind, mit Logs verknüpfen und bei Bedarf Richtlinien ändern.",
      "Ein Entwickler kann via Hook eigene UI-Komponenten oder Aktionen einbinden – z. B. bei Firmenaccounts oder Foren mit Pluginstruktur."
    ],
    "langfristiges ziel": "WebAuthn als technischer Standard *menschlich* umsetzbar machen – nicht als Alibi-Feature, sondern als real benutzbares Element."
  }
}
